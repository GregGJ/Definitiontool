{"code":"/**\r\n * 事件分发器(只有一对多的情况下去使用)\r\n */\r\nexport class EventDispatcher {\r\n    constructor() {\r\n        /**\r\n        * 对象已经注册的处理器\r\n        */\r\n        this.callerMap = new Map();\r\n        /**\r\n         * 事件派发器上所监听的处理器\r\n         */\r\n        this.keyMap = new Map();\r\n    }\r\n    /**\r\n     * 添加事件\r\n     * @param key\r\n     * @param caller\r\n     * @param func\r\n     * @param priority 优先级（数字越小优先级越高）\r\n     */\r\n    addEvent(key, caller, handler, priority = 0) {\r\n        let infoList;\r\n        let info;\r\n        if (this.keyMap.has(key)) {\r\n            infoList = this.keyMap.get(key);\r\n            for (const iterator of infoList) {\r\n                if (iterator.target == caller && iterator.handler == handler) {\r\n                    console.error(\"重复添加同一个事件监听：\" + key + \" \" + caller + \" \" + handler);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            infoList = [];\r\n            this.keyMap.set(key, infoList);\r\n        }\r\n        info = new EventInfo(key, caller, handler);\r\n        infoList.push(info);\r\n        //按照优先级排序\r\n        infoList.sort((a, b) => a.priority - priority);\r\n        //处理器关联处理\r\n        if (this.callerMap.has(caller)) {\r\n            infoList = this.callerMap.get(caller);\r\n            for (const iterator of infoList) {\r\n                if (iterator.key == key && iterator.handler == handler) {\r\n                    console.error(\"事件系统 处理器关联错误：\" + key + \" \" + caller + \" \" + handler);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            infoList = [];\r\n            this.callerMap.set(caller, infoList);\r\n        }\r\n        infoList.push(info);\r\n    }\r\n    /**\r\n     * 删除事件监听\r\n     * @param key\r\n     * @param caller\r\n     * @param handler\r\n     */\r\n    removeEvent(key, caller, handler) {\r\n        if (this.keyMap.has(key) == false) {\r\n            return;\r\n        }\r\n        let infoList = this.keyMap.get(key);\r\n        let info;\r\n        let deleteInfo = null;\r\n        //删除\r\n        for (let index = 0; index < infoList.length; index++) {\r\n            info = infoList[index];\r\n            if (info.target == caller && info.handler == handler) {\r\n                deleteInfo = info;\r\n                infoList.splice(index, 1);\r\n                break;\r\n            }\r\n        }\r\n        infoList = this.callerMap.get(caller);\r\n        //删除\r\n        for (let index = 0; index < infoList.length; index++) {\r\n            info = infoList[index];\r\n            if (info.key == key && info.handler == handler) {\r\n                deleteInfo = info;\r\n                infoList.splice(index, 1);\r\n                break;\r\n            }\r\n        }\r\n        //销毁处理器\r\n        if (deleteInfo) {\r\n            deleteInfo.destroy();\r\n        }\r\n    }\r\n    /**\r\n     * 删除指定对象所有的事件处理\r\n     * @param caller\r\n     */\r\n    removeEventByCaller(caller) {\r\n        let infoList = this.callerMap.get(caller);\r\n        if (infoList === undefined || infoList.length == 0) {\r\n            return;\r\n        }\r\n        let info;\r\n        //逐个删除\r\n        while (infoList.length) {\r\n            info = infoList[0];\r\n            this.removeEvent(info.key, info.target, info.handler);\r\n        }\r\n        //删除空列表\r\n        this.callerMap.delete(caller);\r\n    }\r\n    /**\r\n     * 删除所有事件监听\r\n     */\r\n    removeAllEvent() {\r\n        this.keyMap.forEach(infoList => {\r\n            infoList.forEach(info => {\r\n                info.destroy();\r\n            });\r\n        });\r\n        this.keyMap.clear();\r\n        this.callerMap.clear();\r\n    }\r\n    /**\r\n     * 派发事件\r\n     * @param key\r\n     * @param data\r\n     */\r\n    dispatchEvent(key, data) {\r\n        if (this.keyMap.has(key) == false) {\r\n            return;\r\n        }\r\n        let infoList = this.keyMap.get(key);\r\n        let info;\r\n        for (let index = 0; index < infoList.length; index++) {\r\n            info = infoList[index];\r\n            info.handler.apply(info.target, [key, this, data]);\r\n        }\r\n    }\r\n    /**\r\n     * 是否有事件监听\r\n     * @param key\r\n     */\r\n    hasEvent(key) {\r\n        return this.keyMap.has(key);\r\n    }\r\n    /**\r\n     * 是否包含指定函数事件监听\r\n     * @param key\r\n     * @param caller\r\n     * @param func\r\n     */\r\n    hasEventHandler(key, caller, func) {\r\n        if (this.keyMap.has(key) == false) {\r\n            return false;\r\n        }\r\n        let infoList = this.keyMap.get(key);\r\n        let info;\r\n        for (let index = 0; index < infoList.length; index++) {\r\n            info = infoList[index];\r\n            if (info.target == caller && info.handler == func) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    destroy() {\r\n        this.callerMap.clear();\r\n        this.keyMap.clear();\r\n    }\r\n}\r\nclass EventInfo {\r\n    constructor(key, target, handler) {\r\n        this.key = \"\";\r\n        this.priority = 255;\r\n        this.key = key;\r\n        this.target = target;\r\n        this.handler = handler;\r\n    }\r\n    destroy() {\r\n    }\r\n}\r\n","references":["D:/DefinitionTool/src/drongo/events/IEventDispatcher.ts"]}
